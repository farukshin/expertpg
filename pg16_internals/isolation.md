# Изоляция

* [Согласованность](#Sog)
* [Уровни изоляции и аномалии в стандарте SQL](#Ur)
* [Уровни изоляции в PostgreSQL](#UrPG)
* * [Read Commited](#RC)
* * [Repeatable Read](#RR)
* * [Serializable](#Ser)
* [Какой уровень изоляции использовать?](#Kakoi)

<a name="Sog"></a>

## Согласованность

Важная особенность реляционных СУБД - обеспечение согласованности (consistency), т.е. корректности данных. 

Известно, что на уровне базы данных можно создавать ограничения целостности (integrity constraints), такие как NOT NULL или UNIQUE. СУБД следит, чтобы данные никогда не нарушали эти ограничения, т.е. оставались целостными.
Но есть условия, которые сложны для ограничений на уровне баз данных, например охватывающие несколько  таблиц. 

Согласованность строже, чем целостность, но что конкретно под ней понимается СУБД не знает.Если приложение нарушит согласованность,не нарушая целостности, у СУБД не будет способа узнать об этом. Получается, что гарантом согласованности выступает приложение и остается верить что оно написано корректно и никогда не ошибается.

Транзакция - множество операций, которые переводят базу данных из одного корректного состояния в другое корректное состояние (согласованность), при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция). Это определение объединяет требование, стоящее за первыми буквами акронима ACID:
* Atomicity
* Consistency
* Isolation
* Durability - требование долговечности, веди при крахе системы в ней остаются изменения незафиксированных транзакций, а с ними приходится что-то делать, чтобы восстановить согласованность данных.

<a name="Ur"></a>

## Уровни изоляции и аномалии в стандарте SQL

Стандарт SQL описывает 4 уровня изоляции. Эти уровни определяются перечислением аномалий, которые допускаются или не допускаются при одновременном выполнении транзакции. 

Уровни изоляции
* Read Uncommitted
* Read Committed
* Repeatable Read
* Serializable

Аномалии:
* Потерянное обновление (lost update) - две транзакции читают одну строку, первая делает изменения, потом вторая делает изменения, но без учета изменений первой транзакции. Потерянное обновление не допускается стандартом ни на одном уровне.
* Грязное чтение (dirty read) - возникает, когда транзакция читает еще не зафиксированные изменения другой транзакции.
* Неповторяющееся чтение (non repeatable read) - возникает, когда транзакция читает одну и ту же строку, но между чтениями вторая транзакция изменяет/удаляет эту строку и фиксирует изменения, при этом первая транзакция получит разный результат.
* Фантомное чтение (phantom ) - возникает, когда одна транзакция читает два раза строки, удовлетворяющие определенному диапазону, а между этими чтениями вторая транзакция добавляет строки, удовлетворяющие этому диапазону и фиксирует изменения. Первая транзакция получает разный набор строк.
* Другие аномалии.

Для стандарта SQL

|Уровень изоляции| Потерянные изменения |	«Грязное» чтение|	Неповторяемое чтение|	Фантомное чтение	| Другие аномалии|
|--|--|--|--|--|--|
|Read Uncommitted | - |да|да|да|да|
|Read committed | - |-|да|да|да|
|Repeatable read |-	|-|	-|	да|да|
|Serializable |-	|-	|-	|-	|-|

<a name="UrPG"></a>

## Уровни изоляции в PostgreSQL

Со временем блокировочным протоколам управления транзакциями пришел протокол изоляции на основе снимков (Snapshot Isolation, SI). Идея - каждая транзакция работает с согласованным снимком данных на определенный момент времени. В снимок попадают все актуальные изменения, зафиксированные до момента его создания. 

Изоляция на основе снимков позволяет обходится минимумом блокировок. Фактически блокируется только повторное изменение одной и той же строки. Все остальные операции могут выполняться одновременно: пишущие транзакции никогда не блокируют читающие транзакции, а читающие вообще никогда никого не блокируют. 

В PostgreSQL реализован многоверсионный вариант протокола SI. Грязное чтение не допускается по определению. Формально в PostgreSQL можно указать уровень Read Uncommitted, но работать он будет также как Read Committed. Уровень Repeatable Read не допускает не только неповторяющегося чтения, но и фантомного чтения (хотя и не обеспечивает полную изоляцию). Правда на уровне Read Committed можно в ряде случаев потерять изменения.

|Уровень изоляции| Потерянные изменения |	«Грязное» чтение|	Неповторяемое чтение|	Фантомное чтение	| Другие аномалии|
|--|--|--|--|--|--|
|Read committed | да |-|да|да|да|
|Repeatable read |-	|-|	-|	-|да|
|Serializable |-	|-	|-	|-	|-|


Создадим таблицу счетов. У Алисы и Боба по 1000 руб, но у Боба два счета.

``` sql
CREATE TABLE accounts(
id integer PRIMARY KEY,
client text,
amount numeric
);
```

``` sql
INSERT INTO accounts VALUES
(1, 'alice', 1000.00),
(2, 'bob', 100.00),
(3, 'bob', 900.00);
```

<a name="RC"></a>

### Read Commited

**Отсутствие грязного чтения**. Убедимся, что грязные данные читать невозможно.

``` sql
BEGIN;
SHOW transaction_isolation;
SHOW default_transaction_isolation;

UPDATE accounts SET amount = amount - 200 WHERE id = 1;
SELECT * FROM accounts WHERE client = 'alice';

 id | client | amount 
----+--------+--------
  1 | alice  | 800.00
(1 строка)

```

Во втором сеансе начнем еще одну транзакцию с тем же уровнем Read Committed:

``` sql
| BEGIN;
| SELECT * FROM accounts WHERE client = 'alice';

 id | client | amount  
----+--------+---------
  1 | alice  | 1000.00
(1 строка)
```
Как и ожидалось, вторая транзакция не видит незафиксированные изменения - грязное чтение не допускается.

**Не повторяющееся чтение.** Пусть теперь первая транзакция зафиксирует изменения, а вторая выполнит повторно тот же самый запрос:

``` sql
COMMIT;
```

``` sql
| SELECT * FROM accounts WHERE client = 'alice';

 id | client | amount 
----+--------+--------
  1 | alice  | 800.00
(1 строка)

```

Запрос получает уже новые данные - это и есть аномалия неповторяющееся чтение, которая допускается на уровне Read Committed. 

Вывод: В транзакции нельзя принимать решение на основании данных, прочитанных другим оператором, ведь за время между выполнением операторов все может измениться.

**Не согласованное чтение.** Реализация PostgreSQL такова, что допускает и другие, менее известные аномалии, которые не регламентируются стандартом.

Допустим первая транзакция начала перевод средств с одного счета Боба на другой:

``` sql
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 2;
```

В это время другая транзакция подсчитывает баланс Боба, причем подсчет выполняется в цикле по всем счетам Боба. Фактически транзакция начинает с первого счета:

``` sql
| BEGIN;
| SELECT amount FROM accounts WHERE id = 2;

 amount 
--------
 100.00
(1 строка)

```

В этот момент первая транзакция успешно завершается:

``` sql 
UPDATE accounts SET amount = amount + 100 WHERE id = 3;
COMMIT;
```

А другая считает состояние второго счета:

``` sql 
| SELECT amount FROM accounts WHERE id = 3;
 amount  
---------
 1000.00
(1 строка)
```
В итоге вторая транзакция получила в сумме 1100 руб., т.е. посчитала некорректно данные. Такая аномалия называется *несогласованным чтением* (read skew). 

Как избежать этой аномалии оставаясь на уровне Read Committed? Конечно же использовать один оператор:

``` sql
SELECT sum(amount) FROM accounts WHERE client = 'bob';
```

Видимость данных может поменяться между двумя операторами, но так ли это очевидно? Если запрос выполняется долго, то может ли он увидеть часть данных в одном состоянии, а часть в другом?

Проверим. Удобный способ проверить это - вставить в оператор искусственную задержку, вызвав функцию `pg_sleep`. Первая строка будет прочитана стразу, а вторая через несколько секунд.

``` sql
SELECT amount, pg_sleep(3) FROM accounts WHERE client = 'bob';
```
Пока эта конструкция выполняется, в другой транзакции переводим средства обратно:

``` sql
BEGIN;
UPDATE accounts SET amount = amount + 100 WHERE id = 2;
UPDATE accounts SET amount = amount - 100 WHERE id = 3;
COMMIT;
```

Результат первой транзакции говорит о том, что оператор видит данные в том состоянии, в каком они находились на момент начала выполнения, что, безусловно, правильно:
```
 amount  | pg_sleep 
---------+----------
    0.00 | 
 1000.00 | 
(2 строки)
```

Но и тут не все так просто. Если в запросе вызывается *изменчивая* функция (с категорией изменчивости VOLATILE) и в этой функции выполняется другой запрос, то этот вложенный запрос будет видеть данные, не согласованные с данными основного запроса.

Проверим состояние счетов Боба, используя функцию:

``` sql
CREATE FUNCTION get_amount(id integer) RETURNS numeric
AS $$
SELECT amount FROM accounts a WHERE a.id = get_amount.id;
$$ VOLATILE LANGUAGE sql;

SELECT get_amount(id), pg_sleep(3) FROM accounts WHERE client = 'bob';
```

Пока эта конструкция выполняется, в другой транзакции переводим средства:

``` sql
BEGIN;
UPDATE accounts SET amount = amount + 100 WHERE id = 2;
UPDATE accounts SET amount = amount - 100 WHERE id = 3;
COMMIT;
```

В этом случае получим несогласованные данные - 100 руб пропали:
```
 get_amount | pg_sleep 
------------+----------
     100.00 | 
     800.00 | 
(2 строки)
```

Важно! Такой эффект возможен только на уровне изоляции Read Committed и только с категорией изменчивости VOLATILE. Беда в том, что по умолчанию используется именно этот уровень изоляции и именно эта категория изменчивости. Остается признать - грабли лежат очень удачно. 

**Несогласованное чтение вместо потерянного обновления.** Аномалию несогласованного чтения в рамках одного оператора - несколько неожиданным образом - можно получить и при обновлении.

Посмотрим, что происходит при попытке изменения одной и той же строки разными транзакциями. Сейчас у Боба 1000 руб на двух счетах: 

``` sql
SELECT * FROM accounts WHERE client = 'bob';

 id | client | amount 
----+--------+--------
  2 | bob    | 200.00
  3 | bob    | 800.00
(2 строки)

```

Начинаем транзакцию, которая уменьшает баланс на счетах Боба:

``` sql
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 3;
```

В этот момент другая транзакция начисляет проценты на все счета с общим балансом, равным или превышающим 1000 руб:

``` sql 
UPDATE accounts SET amount = amount * 1.01
WHERE client IN (
    SELECT client
    FROM accounts
    GROUP BY client
    HAVING sum(amount) >= 1000
);
```

Выполнение оператора UPDATE состоит из двух частей. Сначала фактически выполняется SELECT. Поскольку вторая транзакция не видит изменений первой транзакции (которые не зафиксированы), то счета Боба попадают под условия - и после выполнения обновления его баланс должен увеличится на 10 руб.

На втором этапе выполнения выбранные строки обновляются одна за другой. Вторая транзакция вынуждена подождать, поскольку строка `id=3` в настоящий момент изменяется первой транзакцией и поэтому заблокирована.

Между тем первая транзакция фиксирует изменения:

``` sql
COMMIT;
SELECT * FROM accounts WHERE client = 'bob';

 id | client |  amount  
----+--------+----------
  2 | bob    | 202.0000
  3 | bob    | 707.0000
(2 строки)

```

Да, с одной стороны, команда UPDATE не должна видеть изменения второй транзакции. Но с другой - она не должна потерять изменения, зафиксированные во второй транзакции.

После снятия блокировки оператор UPDATE *перечитывает* строку, которую пытается обновить (но только ее одну!). В результате получается, что у Бобу начислено 9 руб, исходя из суммы 900 руб. Но если бы у боба было 900 руб, то его счета вообще не должны были попасть в выборку.

таким образом, транзакция прочитала некорректные данные: часть строк на один момент времени, часть - на другой. Взамен потерянного обновления мы снова получаем аномалию несогласованного чтения.

**Потерянное обновление.** Впрочем хитрость с перечитыванием заблокированной строки не спасает от потери изменений, если обновление происходит не в одном операторе SQL. 

Вот пример который уже был. Приложение читает и запоминает (вне базы) текущий баланс Алисы:

``` sql
BEGIN;
SELECT amount FROM accounts WHERE id = 1;

 amount 
--------
 800.00
(1 строка)

```

В этот момент вторая транзакция действует также:

``` sql
| BEGIN;
| SELECT amount FROM accounts WHERE id = 1;

 amount 
--------
 800.00
(1 строка)

```

Первая транзакция увеличивает заполненное значение на 100 и записывает в базу:

``` sql
UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
RETURNING amount;

 amount 
--------
 900.00
(1 строка)

COMMIT;
```

И вторая транзакция тоже:

``` sql
| UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1
| RETURNING amount;

amount
−−−−−−−−
900.00
(1 row)
UPDATE 1

| COMMIT;
```
К сожалению Алиса не досчиталась 100 руб. СУБД ничего не знает о том, что заполненное значение 800 руб. как-то связано с `accounts.amount` и допускает аномалию потерянного изменения. На уровне изоляции Read Committed такой код некорректен.

<a name="RR"></a>

### Repeatable Read

**Отсутствие неповторяющегося и фантомного чтения.** Само название уровня изоляции Repeatable Read говорит о повторяемости чтения. Проверим это и убедимся в отсутствии фантомов. 

В первой транзакции вернем счета Боба в прежнее состояние и создадим счет для Чарли:

``` sql
BEGIN;
UPDATE accounts SET amount = 200.00 WHERE id = 2;
UPDATE accounts SET amount = 800.00 WHERE id = 3;
INSERT INTO accounts VALUES (4, 'charlie', 100.00);
SELECT * FROM accounts ORDER BY id;

 id | client  | amount 
----+---------+--------
  1 | alice   | 900.00
  2 | bob     | 200.00
  3 | bob     | 800.00
  4 | charlie | 100.00
(4 строки)

```

Во втором сеансе начнем транзакцию с уровнем изоляции Repeatable Read:

``` sql
| BEGIN ISOLATION LEVEL REPEATABLE READ;
| SELECT * FROM accounts ORDER BY id;

 id | client |  amount  
----+--------+----------
  1 | alice  |   900.00
  2 | bob    | 202.0000
  3 | bob    | 707.0000
(3 строки)

```

Теперь первая транзакция фиксирует изменения:

``` sql
COMMIT;
```

А вторая повторно выполняет тот же самый запрос:

``` sql
| SELECT * FROM accounts ORDER BY id;

 id | client |  amount  
----+--------+----------
  1 | alice  |   900.00
  2 | bob    | 202.0000
  3 | bob    | 707.0000
(3 строки)

COMMIT;
```

Вторая транзакция продолжает видеть те же данные что и в начале: не видно ни изменений в существующих строках, ни новых строк. На таком уровне можно не беспокоиться о том, что между двумя операторами что-то поменяется.

**Ошибка сериализации вместо потерянного изменения.**  Как мы уже видели, на уровне изоляции Read Committed при обновлении одной и той же строки двумя транзакциями может возникнуть аномалия несогласованного чтения. Это происходит из-за того, что ожидающая транзакция перечитывает заблокированную строку и видит ее на один момент времени, а остальные строки выборки - на другой. 

На уровне Repeatable Read такая аномалии не допускается, но если она все таки возникает, сделать уже ничего нельзя - поэтому транзакция обрабатывается с ошибкой сериализации. Проверим, повторив тот же сценарий с процентами:

``` sql
SELECT * FROM accounts WHERE client = 'bob';

 id | client | amount 
----+--------+--------
  2 | bob    | 200.00
  3 | bob    | 800.00
(2 строки)

BEGIN;
UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;
```

Вторая транзакция:

``` sql
| BEGIN ISOLATION LEVEL REPEATABLE READ;
| UPDATE accounts SET amount = amount * 1.01
|     WHERE client IN (
|     SELECT client
|     FROM accounts
|     GROUP BY client
|     HAVING sum(amount) >= 1000
| );
```
Вторая транзакция переходит в ожидание.

Фиксируем изменения в первой транзакции

``` sql
COMMIT;
```

Во второй получаем ошибку:
``` sql
ОШИБКА:  не удалось сериализовать доступ из-за параллельного изменения
| ROLLBACK;
```

Данные остались соглосованными:

``` sql
postgres=# SELECT * FROM accounts WHERE client = 'bob';
 id | client | amount 
----+--------+--------
  2 | bob    | 200.00
  3 | bob    | 700.00
(2 строки)
```

Такая же ошибка будет в случае другого конкурентного изменения строки, даже если оно не затрагивает интересующие нас столбцы.

Можно проверить, что сценарий с приложениями, обновляющими баланс на основе заполненного значения, приводит к той же ошибки:

``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT amount FROM accounts WHERE id = 1;

 amount 
--------
 900.00
(1 строка)
```

Второй сеанс:

``` sql
| BEGIN ISOLATION LEVEL REPEATABLE READ;
| SELECT amount FROM accounts WHERE id = 1;

 amount 
--------
 900.00
(1 строка)
```

Первый:
``` sql
UPDATE accounts SET amount = 900.00 + 100.00 WHERE id = 1
RETURNING amount;

 amount  
---------
 1000.00
(1 строка)

COMMIT;
```

Ошибка во второй транзакции:

``` sql
| UPDATE accounts SET amount = 900.00 + 100.00 WHERE id = 1 RETURNING amount;
ОШИБКА:  не удалось сериализовать доступ из-за параллельного изменения
| ROLLBACK;
```

Вывод: если приложение использует уровень изоляции Repeatable Read для пишущих транзакций, он должно быть готово повторять транзакции, завершившиеся с ошибкой сериализации. Для только читающих транзакций такой исход невозможен.

**Несогласованная запись.**  Итак, в PostgreSQL на уровне изоляции Repeatable Read предотвращаются все аномалии, описанные в стандарте. Но не все воодще - науке до сих пор неизвестно, сколько их существует. Однако докуазн важный факт: изоляция на основе снимков оставляет возможным ровно две аномалии, сколько бы их не было всего. 

Первая из них - несогласованная запись (write skew). 

Пусть действует такое правило согласованности - допускаются отрицательные суммы на отдельных счетах клиента, если общая сумма на всех счетах этого клиента остается неотрицательной.

Первая транзакция получает сумму на счетах Боба:

``` sql 
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT sum(amount) FROM accounts WHERE client = 'bob';

  sum   
--------
 900.00
(1 строка)
```

Вторая транзакция получает ту же сумму:

``` sql
| BEGIN ISOLATION LEVEL REPEATABLE READ;
| SELECT sum(amount) FROM accounts WHERE client = 'bob';

  sum   
--------
 900.00
(1 строка)
```

Первая транзакция справедливо полагает, что сумму одного из счетов мож-
но уменьшить на 600 руб:

``` sql
UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;
```

И вторая транзакция приходит к такому же выводу. Но уменьшает другой
счет:

``` sql
| UPDATE accounts SET amount = amount - 600.00 WHERE id = 3;
| COMMIT;
```

Первая фиксирует транзакцию:

``` sql
COMMIT;
SELECT * FROM accounts WHERE client = 'bob';

 id | client | amount  
----+--------+---------
  2 | bob    | -400.00
  3 | bob    |  100.00
(2 строки)
```

У нас получилось увести баланс Боба в минус, хотя по одиночке каждая транзакция отработала бы по корректно.

**Аномалия только читающей транзакции.** Аномалия только читающей транзакции - вторая и последняя из аномалий, возможных на уровне Repeatable Read. Чтобы продемонстрировать ее, потребуется три транзакции, две из которых будут изменять данные, а третья только читать.

Но сначала восстановим состояние счетов Боба:

``` sql
UPDATE accounts SET amount = 900.00 WHERE id = 2;
SELECT * FROM accounts WHERE client = 'bob';

 id | client | amount 
----+--------+--------
  3 | bob    | 100.00
  2 | bob    | 900.00
(2 строки)
```

Первая транзакция начисляет Бобу проценты на сумму средств на всех счетах. Проценты начисляются на один из его счетов:

``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ; -- 1
UPDATE accounts SET amount = amount + (
    SELECT sum(amount) FROM accounts WHERE client = 'bob') * 0.01 WHERE id = 2;
```

Затем другая транзакция снимает деньги с другого счета Боба и фиксирует свои изменения:

``` sql
| BEGIN ISOLATION LEVEL REPEATABLE READ; -- 2
| UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;
| COMMIT;
```

Если в этот момент первая транзакция будет зафиксирована, то никакой аномалии не возникнет. Но представим, что в этот момент третья (только читающая) транзакция запрашивает сумму на счетах Боба. Она может видеть изменения второй транзакции, которая уже была зафиксирована, но не первой (которая еще не зафиксирована):

``` sql
|| SELECT * FROM accounts WHERE client = 'bob'; -- 3

 id | client | amount 
----+--------+--------
  2 | bob    | 900.00
  3 | bob    |   0.00
(2 строки)
```

С другой стороны, мы уже установили выше, что вторую транзакцию следует считать начавшейся после первой. Последствия аномалии становятся понятными после завершения первой транзакции:

``` sql
COMMIT;
```

У Боба на счетах всего 900 руб (что показала только читающая транзакция), а проценты оказались начисленными на все 1000 руб:

``` sql
SELECT * FROM accounts WHERE client = 'bob';

 id | client |  amount  
----+--------+----------
  2 | bob    | 910.0000
  3 | bob    |     0.00
(2 строки)
```

<a name="Ser"></a>

### Serializable

На уровне Serializable предотвращаются все возможные аномалии. фактически Serializable реализован как надстройка над изоляцией на основе снимков данных. Те аномалии, которые не возникают при Repeatable Read  (такие как грязное, неповторяемое, фантомное чтения), не возникает и на уровне Serializable. А те две аномалии, которые возникают (несогласованная запись и аномалия только читающей транзакции), специальным образом обнаруживаются, и в этом случае транзакция обрывается: возникает ошибка сериализации.

**Отсутствие аномалий.** Можно убедиться, что сценарии с аномалией несогласованной записи приведет к ошибке сериализации:

``` sql
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT sum(amount) FROM accounts WHERE client = 'bob';

   sum    
----------
 910.0000
(1 строка)
```

Вторая транзакция:

``` sql
| BEGIN ISOLATION LEVEL SERIALIZABLE;
| SELECT sum(amount) FROM accounts WHERE client = 'bob';

   sum    
----------
 910.0000
(1 строка)
```

Уменьшение суммы в первой транзакции:
``` sql
UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;
```
Уменьшение во второй:
``` sql
| UPDATE accounts SET amount = amount - 600.00 WHERE id = 3;
| COMMIT;
```

Теперь при попытке зафкисировать первую транзакцию поулчим ошибку сериализации:

``` sql
COMMIT;

ОШИБКА:  не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями
ПОДРОБНОСТИ:  Reason code: Canceled on identification as a pivot, during commit attempt.
ПОДСКАЗКА:  Транзакция может завершиться успешно при следующей попытке.
```

К такой же ошибке приведет и сценарий аномалии только читающей транзакции

**Откладывание читающей транзакции.** Чтобы только читающая транзакция не приводила к аномалии и не могла пострадать от нее, PostgreSQL предлагает интересный механизм: такая транзакция может быть отложена до тех пор, пока ее выполнение не станет безопасным. Это единственный случай, когда оператор SELECT может быть заблокирован обновлениями строк.

Посмотрим на примере сценария аномалии только читающей транзакции:

``` sql
UPDATE accounts SET amount = 900.00 WHERE id = 2;
UPDATE accounts SET amount = 100.00 WHERE id = 3;
SELECT * FROM accounts WHERE client = 'bob' ORDER BY id;

 id | client | amount 
----+--------+--------
  2 | bob    | 900.00
  3 | bob    | 100.00
(2 строки)
```

Первая транзакция 

``` sql
BEGIN ISOLATION LEVEL SERIALIZABLE; -- 1
UPDATE accounts SET amount = amount + (
    SELECT sum(amount) FROM accounts WHERE client = 'bob'
    ) * 0.01 WHERE id = 2;
```

Вторая транзакция:

``` sql
| BEGIN ISOLATION LEVEL SERIALIZABLE; -- 2
| UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;
| COMMIT;
```
Третью транзакцию явно объявляем только читающей (READ ONLY)

``` sql
|| BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE; -- 3
|| SELECT * FROM accounts WHERE client = 'alice';
```
При попытке выполнить запрос транзакция блокируется, потому что иначе
она приведет к аномалии.
И только после того, как первая транзакция будет зафиксирована, третья
продолжит выполнение:

``` sql
COMMIT;
```
в третьей транзакции выведется результат:

``` sql
 id | client | amount  
----+--------+---------
  1 | alice  | 1000.00
(1 строка)

SELECT * FROM accounts WHERE client = 'bob';

 id | client |  amount  
----+--------+----------
  2 | bob    | 910.0000
  3 | bob    |     0.00
(2 строки)

COMMIT;
```

Таким образом, приложение, использующее уровень изоляции Serializable, должно повторять транзакции, завершившиеся ошибкой сериализации. (Точно так же следует поступать и на уровне Repeatable Read, если не ограничиваться только читающими транзакциями.)

Уровень Serializable дает простоту программирования, но цена за нее — накладные расходы на обнаружение возможных аномалий и обрыв некоторой доли транзакций. Снизить накладные расходы можно, явно обозначая только читающие транзакции как READ ONLY. Но главный вопрос, конечно, в том, насколько велика доля оборванных транзакций, ведь их придется выполнять повторно. Если бы обрывались только те транзакции, которые действительно несовместимо пересекаются по данным, все было бы неплохо. Но такая реализация неизбежно оказалась бы слишком ресурсоемкой, поскольку пришлось бы отслеживать операции с каждой строкой.

В действительности реализация такова, что допускает ложноположительные срабатывания: будут обрываться и некоторые совершенно нормальные транзакции, которым «просто не повезло».

Если используется уровень изоляции Serializable, он должен применяться для всех транзакций приложения. При смешении транзакций разного уровня изоляции уровень Serializable будет (без всяких предупреждений) вести себя как Repeatable Read. Поэтому при использовании Serializable имеет смысл изменить значение параметра default_transaction_isolation, хотя, конечно, это не помешает указать неправильный уровень явно.

<a name="Kakoi"></a>

## Какой уровень изоляции использовать?

Уровень изоляции Read Committed используется в PostgreSQL по умолчанию, и, по всей видимости, именно этот уровень применяется в абсолютном большинстве приложений. Он удобен тем, что на нем обрыв транзакции возможен только в случае сбоя, но для предотвращения несогласованности обрыв не применяется. Иными словами, ошибка сериализации возникнуть не может, и о повторении транзакций заботиться не надо.

Обратная сторона медали — большое число возможных аномалий. Разработчик вынужден постоянно иметь их в виду и писать код так, чтобы не допускать их появления. Если не получается сформулировать нужные действия в одном SQL-операторе, приходится прибегать к явной установке блокировок. Самое неприятное то, что код сложно тестировать на наличие ошибок, связанных с получением несогласованных данных, а сами ошибки могут возникать непредсказуемым и невоспроизводимым образом и поэтому сложны в исправлении.

Уровень изоляции Repeatable Read снимает часть проблем несогласованности, но, увы, не все. Поэтому приходится не только помнить об оставшихся аномалиях, но и изменять приложение так, чтобы оно корректно обрабатывало ошибки сериализации. Это, конечно, неудобно. Но для только читающих транзакций этот уровень прекрасно дополняет Read Committed и полезен, например, для построения отчетов, использующих несколько SQL-запросов.

Наконец, уровень Serializable позволяет вообще не заботиться о несогласованности, что значительно упрощает написание кода. Единственное, что требуется от приложения, — уметь повторять любую транзакцию при получении ошибки сериализации. Но доля прерываемых транзакций и дополнительные накладные расходы могут существенно снизить пропускную способность. Также следует учитывать, что уровень Serializable не применим на репликах и что его нельзя смешивать с другими уровнями изоляции.