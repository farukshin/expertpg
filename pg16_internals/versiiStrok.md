# Страницы и версии строк

* [Структура страниц](#struct)
* [Структура версии строк](#structVer)
* [Выполнение операций над версиями строк](#op)
* [Индексы](#index)
* [TOAST](#toast)
* [Виртуальные трензакции](#virt)
* [Вложенные транзакции](#vl)

<a name="struct"></a>

## Структура страниц

Каждая страница имеет внутреннюю структуру, как правило содержит следующие разделы:

* заголовок
* массив указателей на версии строк
* свободное пространство
* версии строк
* специальную область

**Заголовок страницы**

Заголовок страницы располагается в младших адресах и имеет фиксированный размер. Он хранит различную информацию, такую как контрольная сумма, а также размер всех остальных областей.

Размер легко получить с помощью расширения `pageinspect`. Заглянем в самую первую страницу таблицы (нумерация начинается с нуля):

``` sql
CREATE EXTENSION pageinspect;
SELECT lower, upper, special, pagesize
FROM page_header(get_raw_page('accounts',0));

 lower | upper | special | pagesize 
-------+-------+---------+----------
   152 |  6904 |    8192 |     8192
(1 строка)
```

![Заголовок](./img/zagolovok.png)

**Специальная область**

Специальная область расположена в противоположенном конце страницы, в старших адресах. Она используется некоторыми типами индексов для хранения вспомогательной информации.

В целом индексные страницы устроены более разнообразно, и их содержимое зависит от конкретного типа индекса. И даже у одного типа индекса бывают разные виды страниц.

**Версии строк** 

Перед специальной областью располагаются *строки (rows)* - те самые данные, которые хранятся в базе, с добавлением некоторой служебной информации.

В случае таблиц, мы говорим не просто о строках, а о версиях строк, поскольку многоверсионность предполагает существование нескольких версий одной и той же строки. На индексы многоверсионность не распространяется, вместо этого индексы ссылаются на все возможные табличные версии строк, среди которых по правилам видимости выбираются подходящие.

**Указатели на версии строк**

Массив указателей на версии строк служит оглавлением страницы. Он располагается сразу за заголовком.

Индексные строки должны как-то ссылаться на версии строк в таблице. Для этого используются шестибайтные идентификаторы версий строк (tuple id, tid). Идентификатор состоит из номера страницы в файле основного слоя и должен еще содержать какое-то указание на версию строки в этой странице.

В качестве такого указания можно было бы использовать смещение относительно начала страницы. Но тогда версию строки нельзя было бы перемещать внутри страницы, не сломав ссылки из индексов. А это привело бы к фрагментации места внутри страниц и другим неприятным последствиям.

Поэтому используется косвенная адресация: идентификатор версии ссылается на номер указателя, а уже указатель — на текущую позицию версии строки в странице. При перемещении версии строки ее идентификатор не меняется; достаточно изменить указатель, который находится на той же странице.

Каждый указатель занимает ровно 4 байта и содержит:

* смещение версии строки относительно начала страницы
* длину версии строки
* несколько битов, определяющих статус версии строки

**Свободное место**

Между указателями и версиями строк может оставаться свободное место. Никакой фрагментации страницы не бывает, все свободное место всегда представлено одним фрагментом.

<a name="structVer"></a>

## Структура версии строк

Версия строки состоит из заголовка, за которым следуют собственно данные. Заголовок версии содержит множество полей, среди которых:

*xmin,xmax - номера транзакций, которые отличают данную версию от других версий той же строки;

* infomask - ряд информационных битов, определяющих свойство версии;

* ctid - ссылка на следующую, более новую версию той же строки;

* битовая карта неопределенных значений - массив битов, отмечающих столбцы, которые допускают неопределенные значения (NULL).

В результате заголовок получается довольно большой - 23 байта на каждую версию строки, а обычно больше из за карты неопределенных значений и из-за обязательного выравнивания начала данных. Для "узкой" таблицы объем служебных данных может превышать объем полезных данных.

Формат данных на диске полностью совпадает с представление данных в оперативной памяти. Страница вместе с версиями строк читается в буферный кеш "как есть", без каких бы то ни было преобразований. Поэтому файлы данных с одной платформы оказываются несовместимыми с другими платформами.

<a name="op"></a>

## Выполнение операций над версиями строк

Чтобы разные версии одной и той же строки можно было различить, каждая из версий имеет две отметки, определяющие ее «время действия», — xmin и xmax. Но используется не время как таковое, а постоянно увеличивающийся счетчик номеров транзакций.

Когда строка создается, значение xmin устанавливается равным номеру транзакции, выполнившей команду INSERT.

Когда строка удаляется, значению xmax текущей версии присваивается номер транзакции, выполнившей команду DELETE.

Команду UPDATE можно в некотором приближении рассматривать как две операции: DELETE и INSERT. В текущей версии строки устанавливается значение xmax, равное номеру транзакции, выполнившей UPDATE. Затем создается новая версия той же строки; значение xmin у нее совпадает со значением xmax предыдущей версии. Точно так же и команда MERGE «распадается» на элементарные вставки и удаления.

Посмотрим, как выполняются разные операции с версиями строк на низком уровне 1.

Для экспериментов понадобится таблица с двумя столбцами и индексом по одному из них:

``` sql
CREATE TABLE t(
id integer GENERATED ALWAYS AS IDENTITY,
s text
);
CREATE INDEX ON t(s);
```

### Вставка

``` sql
BEGIN;
INSERT INTO t(s) VALUES ('FOO');
```

Номер нашей текущей транзакции:

```sql
SELECT pg_current_xact_id();

 pg_current_xact_id 
--------------------
                769
(1 строка)
```

Заглянем в содержимое страницы. Функция heap_page_items дает нам всю необходимую информацию, но показывает данные «как есть», в формате, сложном для восприятия. Создадим функцию

``` sql
CREATE FUNCTION heap_page(relname text, pageno integer)
RETURNS TABLE(ctid tid, state text, xmin text, xmax text)
AS $$
SELECT (pageno,lp)::text::tid AS ctid,
CASE lp_flags
WHEN 0 THEN 'unused'
WHEN 1 THEN 'normal'
WHEN 2 THEN 'redirect to '||lp_off
WHEN 3 THEN 'dead'
END AS state,
t_xmin || CASE
WHEN (t_infomask & 256) > 0 THEN ' c'
WHEN (t_infomask & 512) > 0 THEN ' a'
ELSE ''
END AS xmin,
t_xmax || CASE
WHEN (t_infomask & 1024) > 0 THEN ' c'
WHEN (t_infomask & 2048) > 0 THEN ' a'
ELSE ''
END AS xmax
FROM heap_page_items(get_raw_page(relname,pageno))
ORDER BY lp;
$$ LANGUAGE sql;
```
В таком виде уже значительно понятнее, что творится в заголовке версии:

``` sql
SELECT * FROM heap_page('t',0);
 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769   | 0 a
(2 строки)
```

Похожую, но существенно менее детальную информацию можно получить и из самой таблицы, используя псевдостолбцы xmin и xmax:

``` sql
SELECT xmin, xmax, * FROM t;

 xmin | xmax | id |  s  
------+------+----+-----
  769 |    0 |  2 | FOO
(1 строка)
```

### Фиксация

При успешном завершении транзакции нужно заполнить ее статус - отметить, что она зафиксирована. Для этого используется структура, называемая `clog (commit log)`. Это не специальная таблица системного каталога, а специальные файлы в каталоге PGDATA/pg_xact. В версии 10 каталог переименовали, раньше был  PGDATA/pg_clog, иногда админы его удаляли.

В clog, как и в заголовке версии строки, для каждой транзакции отведено два битаЖ committed и aborted.

При фиксации транзакции в clog выставляется бит committed для данной транзакции. Когда какая-либо другая транзакция обратится к нашей табличной странице, ей придется ответить на вопрос: завершилась ли транзакция с номером xmin?

* Если нет, то созданная версия строки не должна быть видна. Чтобы проверить, выполняется ли транзакция, просматривается еще одна структура, которая располагается в общей памяти экземпляра и называется ProcArray. В ней находится список всех активных процессов, и для каждого указан номер его текущей (активной) транзакции.

* Если завершилась, то фиксацией или отменой? При отмене версия строки тоже не должна быть видна. Для этой проверки как раз и нужна структура clog. Но хотя последние страницы clog сохраняются в буферах в оперативной памяти, все равно такую проверку накладно выполнять каждый раз. Поэтому выясненный однажды статус транзакции записывается в заголовок версии строки в информационные биты xmin_committed и xmin_aborted; их еще называют битами-подсказками (hint bits). Если один из этих битов установлен, то состояние транзакции xmin считается известным, и следующей транзакции уже не придется обращаться ни к clog, ни к ProcArray.

Почему эти биты не устанавливаются той транзакцией, которая вставляет строку? Дело в том, что в это время транзакция еще не знает, завершится ли она успешно. А в момент фиксации уже не понятно, какие именно строки в каких именно страницах были изменены. Таких страниц может оказаться много, и запоминать их невыгодно. К тому же часть страниц может быть вытеснена из буферного кеша на диск; читать их заново, чтобы изменить биты, означало бы существенно замедлить фиксацию. Обратная сторона экономии состоит в том, что любая транзакция (даже выполняющая простое чтение — SELECT) может начать выставлять информационные биты в страницах данных. Конечно, страницы в буферном кеше при этом становятся грязными. 

Зафиксируем наконец вставку строки, с которой мы начали транзакцию:

```sql
COMMIT;
```

В странице ничего не изменилось (но мы знаем, что статус транзакции уже
записан в clog):

```sql
SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769   | 0 a
(2 строки)
```

Теперь транзакция, первой обратившаяся к странице («нормальным» образом, не с помощью pageinspect), должна будет определить статус транзакции xmin и записать его в информационные биты:

```sql
SELECT * FROM t;

 id |  s  
----+-----
  2 | FOO
(1 строка)
```

```sql
SELECT * FROM t;

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769 c | 0 a
(2 строки)
```

### Удаление

При удалении строки в поле xmax актуальной версии записывается номер удаляющей транзакции, а бит xmax_aborted сбрасывается.

Удалим строку:

```sql
BEGIN;
DELETE FROM t;
SELECT pg_current_xact_id();

 pg_current_xact_id 
--------------------
                770
(1 строка)
```

Номер транзакции записался в поле xmax, но информационные биты еще не
установлены:

```sql
SELECT * FROM heap_page('t',0);
 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769 c | 770
(2 строки)

```

### Отмена

Отмена изменений работает аналогично фиксации и выполняется так же быстро, только в clog вместо бита committed выставляется бит aborted. Хоть команда и называется ROLLBACK, отката изменений не происходит: все, что транзакция успела изменить в страницах данных, остается на месте.

```sql
ROLLBACK;
SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769 c | 770
(2 строки)
```

При обращении к странице проверяется статус, и в версии строки устанавливается бит-подсказка xmax_aborted. Сам номер xmax при этом остается в странице, но смотреть на него уже никто не будет:

```sql
SELECT * FROM t;

 id |  s  
----+-----
  2 | FOO
(1 строка)

SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax  
-------+--------+-------+-------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769 c | 770 a
(2 строки)
```

### Обновление

Обновление работает так, как будто сначала выполнилось удаление текущей версии строки, а затем — вставка новой:

```sql
BEGIN;
UPDATE t SET s = 'BAR';
SELECT pg_current_xact_id();

UPDATE 1
 pg_current_xact_id 
--------------------
                771
(1 строка)
```

Запрос выдает одну строку (новую версию):

```sql
SELECT * FROM t;

 id |  s  
----+-----
  2 | BAR
(1 строка)
```

Но в странице хранятся обе версии:

```sql
SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 754 a | 0 a
 (0,2) | normal | 769 c | 771
 (0,3) | normal | 771   | 0 a
(3 строки)
```

Удаленная ранее версия помечена номером текущей транзакции в поле xmax. Это значение записано поверх старого, поскольку предыдущая транзакция была отменена. А бит xmax_aborted сброшен, так как статус текущей транзакции еще неизвестен.

Ну и завершим транзакцию.

``` sql
COMMIT;
```

<a name="index"></a>

## Индексы

В индексах любого типа никогда не бывает версий строк, каждая строка представлена ровно одним экземпляром. Иными словами, в заголовке индексной строки не бывает полей `xmin` и `xmax`. Ссылки из индекса ведут на все табличные версии строк. Транзакции требуется заглянуть в таблицу, чтобы разобраться, какая из версий ей видна (если только страница не отмечена в карте видимости).

Для удобства создадим простую функцию, показывающую с помощью расширения pageinspect все индексные записи на странице (в пределах страницы B-дерева записи располагаются в виде плоского списка):

``` sql
CREATE FUNCTION index_page(relname text, pageno integer)
RETURNS TABLE(itemoffset smallint, htid tid)
AS $$
SELECT itemoffset,
htid -- ctid до v.13
FROM bt_page_items(relname,pageno);
$$ LANGUAGE sql;
```

Обнаруживаем на странице указатели на обе версии табличной строки, как
на актуальную, так и на старую:

``` sql
SELECT * FROM index_page('t_s_idx',1);

 itemoffset | htid  
------------+-------
          1 | (0,3)
          2 | (0,1)
          3 | (0,2)
(3 строки)
```

Поскольку BAR < FOO, указатель на вторую версию строки стоит в индексе на первом месте.

<a name="toast"></a>

## TOAST

Toast-таблица является, по сути, обычной таблицей, и для нее поддерживается собственная версионность: версии «тостов» не связаны с версиями строк основной таблицы. Но внутренняя работа с toast-таблицей построена так, что строки никогда не обновляются, а только добавляются и удаляются, так что версионность в данном случае несколько вырожденная.

Когда данные меняются, в основной таблице всегда создается новая версия строки. Но если обновление не затрагивает «длинное» значение, хранящееся в TOAST, то новая версия строки будет ссылаться на прежнее значение в toast-таблице. И только когда обновление поменяет «длинное» значение, будут созданы и новая версия строки в основной таблице, и новые «тосты».

<a name="virt"></a>

## Виртуальные транзакции

PostgreSQL использует оптимизацию, позволяющую «экономить» номера транзакций.

Если транзакция только читает данные, то она никак не влияет на видимость версий строк. Поэтому вначале обслуживающий процесс выдает транзакции виртуальный номер 1 (virtual xid). Номер состоит из идентификатора обслуживающего процесса и последовательного числа. Выдача этого номера не требует синхронизации между всеми процессами и поэтому выполняется очень быстро.

``` sql
BEGIN;
SELECT pg_current_xact_id_if_assigned();

 pg_current_xact_id_if_assigned 
--------------------------------
                               
(1 строка)
```

Виртуальные номера существуют только в оперативной памяти, пока транзакция активна; они никогда не записываются в страницы данных и не попадают на диск.

Если же транзакция начинает менять данные, ей выдается настоящий, уникальный номер транзакции:

``` sql
UPDATE accounts
SET amount = amount - 1.00;
SELECT pg_current_xact_id_if_assigned();

 pg_current_xact_id_if_assigned 
--------------------------------
                            773
(1 строка)

COMMIT;
```

<a name="vl"></a>

## Вложенные транзакции

### Точки сохранения

В SQL определены точки сохранения (savepoint), которые позволяют отменить часть операций транзакции, не прерывая ее полностью. Но это не укладывается в приведенную выше схему, поскольку статус транзакции один на все изменения, а физически никакие данные не откатываются.

Чтобы реализовать такой функционал, транзакция с точкой сохранения разбивается на несколько вложенных транзакций 1 (subtransaction), статусом которых можно управлять отдельно.

Вложенные транзакции имеют свой собственный номер (больший, чем номер основной транзакции). Статус вложенных транзакций записывается в clog обычным образом, но зафиксированные вложенные транзакции одновременно отмечаются двумя битами, committed и aborted. Финальный статус зависит от статуса основной транзакции: если она отменена, то и все вложенные транзакции считаются отмененными.

Информация о вложенности транзакций хранится в файлах внутри каталога `PGDATA/pg_subtrans`.

Очистим таблицу, начнем транзакцию и вставим строку:

``` sql
TRUNCATE TABLE t;
BEGIN;
INSERT INTO t(s) VALUES ('FOO');
SELECT pg_current_xact_id();

 pg_current_xact_id 
--------------------
                778
(1 строка)
```

Теперь поставим точку сохранения и вставим еще одну строку:

``` sql
SAVEPOINT sp;
INSERT INTO t(s) VALUES ('XYZ');
SELECT pg_current_xact_id();

 pg_current_xact_id 
--------------------
                778
(1 строка)
```

Заметьте, что функция pg_current_xact_id выдает номер основной, а не вложенной транзакции.

``` sql
SELECT *
FROM heap_page('t',0) p
LEFT JOIN t ON p.ctid = t.ctid;

 ctid  | state  | xmin | xmax | id |  s  
-------+--------+------+------+----+-----
 (0,1) | normal | 778  | 0 a  |  5 | FOO
 (0,2) | normal | 779  | 0 a  |  6 | XYZ
(2 строки)
```

Откатимся к точке сохранения и вставим третью строку:

``` sql
ROLLBACK TO sp;
INSERT INTO t(s) VALUES ('BAR');
SELECT *
FROM heap_page('t',0) p
LEFT JOIN t ON p.ctid = t.ctid;

 ctid  | state  | xmin | xmax | id |  s  
-------+--------+------+------+----+-----
 (0,1) | normal | 778  | 0 a  |  5 | FOO
 (0,2) | normal | 779  | 0 a  |    | 
 (0,3) | normal | 780  | 0 a  |  7 | BAR
(3 строки)
```

В странице мы продолжаем видеть строку, добавленную отмененной вложенной транзакцией.

Фиксируем изменения:

``` sql
COMMIT;
SELECT * FROM t;

 id |  s  
----+-----
  5 | FOO
  7 | BAR
(2 строки)

SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 778 c | 0 a
 (0,2) | normal | 779 a | 0 a
 (0,3) | normal | 780 c | 0 a
(3 строки)
```

Теперь хорошо видно, что каждая вложенная транзакция имеет собственный статус.

Вложенные транзакции нельзя использовать в SQL напрямую, то есть нельзя начать новую транзакцию, не завершив текущую:

``` sql
BEGIN;
BEGIN
=> BEGIN;
WARNING:  there is already a transaction in progress
BEGIN
=> COMMIT;
COMMIT
=> COMMIT;
WARNING:  there is no transaction in progress
```

Этот механизм задействуется неявно: при использовании точек сохранения, при обработке исключений PL/pgSQL и в некоторых других, более экзотических случаях.


### Ошибки и атомарность операций

Что случится, если в процессе выполнения операции произойдет ошибка?

``` sql
BEGIN;
SELECT * FROM t;
 id |  s  
----+-----
  5 | FOO
  7 | BAR
(2 строки)

UPDATE t SET s = repeat('X', 1/(id-5));

ERROR:  division by zero
```

После сбоя транзакция считается прерванной, и больше ни одна операция в ней не допускается:

``` sql
SELECT * FROM t;

ERROR:  current transaction is aborted, commands ignored until end of transaction block
```

И даже если попытаться зафиксировать изменения, PostgreSQL сообщит об отмене:

``` sql
COMMIT;
```

Почему нельзя продолжить выполнение транзакции после сбоя? Поскольку уже выполненные действия никогда не откатываются, мы получили бы доступ к части изменений, выполненных до ошибки, — была бы нарушена атомарность даже не транзакции, а оператора. Как в нашем примере, где оператор до ошибки успел обновить одну строку из двух:

``` sql
SELECT * FROM heap_page('t',0);

 ctid  | state  | xmin  | xmax 
-------+--------+-------+------
 (0,1) | normal | 778 c | 781
 (0,2) | normal | 779 a | 0 a
 (0,3) | normal | 780 c | 781
 (0,4) | normal | 781   | 0 a
 (0,5) | normal | 781   | 0 a
(5 строк)
```

К слову, в psql имеется режим, который все-таки позволяет продолжать работу транзакции после сбоя так, как будто действия ошибочного оператора откатываются:

``` sql
\set ON_ERROR_ROLLBACK on
BEGIN;
UPDATE t SET s = repeat('X', 1/(id-7));

ERROR:
division by zero

SELECT * FROM t;

 id |  s  
----+-----
  5 | FOO
  7 | BAR
(2 строки)

COMMIT;

>COMMIT;
```

Нетрудно догадаться, что в таком режиме psql фактически ставит перед каждой командой неявную точку сохранения, а в случае сбоя инициирует откат к ней. Такой режим не используется по умолчанию, поскольку установка точек сохранения (даже без отката к ним) сопряжена с существенными накладными расходами.